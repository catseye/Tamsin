# Interpreter for "Micro-Tamsin", written in Tamsin.
# (see doc/Micro-Tamsin.markdown.)
# Distributed under a BSD-style license; see LICENSE.

# REQUIRES lib/tamsin_scanner.tamsin
# REQUIRES lib/tamsin_parser.tamsin

# Note that this may contain support for some features which are not in
# the current released or pre-released version.

main = tamsin_parser:parse → AST & {" " | "\n"} & "/" & interpret(AST, AST).

interpret(PROGRAM, program(L)) =
    find_main_module_prods(L) → MMP &
    find_prod(main, MMP) → Main &
    interpret(PROGRAM, Main).

interpret(PROGRAM, production(N, F, E)) = interpret(PROGRAM, E).
interpret(program(L), call(prodref('$', 'return'), list(X, nil))) = return X.
interpret(program(L), call(prodref('$', 'expect'), list(X, nil))) = «X».
interpret(program(L), call(prodref('$', 'print'), list(X, nil))) = print X.

interpret(program(L), call(prodref(M, N), A)) =
    find_main_module_prods(L) → MMP &
    find_prod(N, MMP) → P &
    interpret(program(L), P).

interpret(PROGRAM, or(L, R)) = interpret(PROGRAM, L) | interpret(PROGRAM, R).
interpret(PROGRAM, and(L, R)) = interpret(PROGRAM, L) & interpret(PROGRAM, R).
interpret(PROGRAM, not(X)) = !interpret(PROGRAM, X).
interpret(PROGRAM, while(X)) = {interpret(PROGRAM, X)}.

find_main_module_prods(list(module(main, Ps),T)) = Ps.
find_main_module_prods(list(H,T)) = find_main_module_prods(T).
find_main_module_prods(nil) = fail 'no main module'.

find_prod(N1, list(production(N2, F, E),T)) =
    $:equal(N1, N2) & return production(N2, F, E) | find_prod(N1, T).
find_prod(N, list(H,T)) = find_prod(N, T).
find_prod(N, nil) = fail 'no ' + N + ' production'.
