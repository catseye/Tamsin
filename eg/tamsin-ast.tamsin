# Parser for Tamsin AST, written in Tamsin.
# Distributed under a BSD-style license; see LICENSE.

main = grammar using $.tamsin.

grammar    = {"@" & pragma & "."} &
             L ← nil &
             production → P & "." &
             L ← list(P, L) &
             {
                 production → P & "." &
                 L ← list(P, L)
             } &
             eof &
             reverse(L, nil) → L &
             return program(L).
production = word → N &
             F ← nil &
             [formals → F] &
             "=" &
             expr0 → E &
             return production(N, F, E).
formals    = L ← nil &
             "(" &
             term → T & L ← list(T, L) &
             {"," & term → T & L ← list(T, L)} &
             ")" & return L
             | "[" & expr0 & "]".
expr0      = expr1 → L & {("|" | "||") & expr1 → R & L ← or(L, R)} & L.
expr1      = expr2 → L & {("&" | "&&") & expr2 → R & L ← and(L, R)} & L.
expr2      = expr3 → L & ["using" & prodref → P & L ← using(L, P)] & L.
expr3      = expr4 → L & [("→" | "->") & variable → V & L ← send(L, V)] & L.
expr4      = "(" & expr0 → E & ")" & E
           | "[" & expr0 → E & "]" & return opt(E)
           | "{" & expr0 → E & "}" & return while(E)
           | "!" & expr4 → E & return not(E)
           | "set" & variable → V & "=" & term → T & return set(V, T)
           | "return" & term → T & return call(prodref('$', return), list(T, nil))
           | "fail" & term → T & return call(prodref('$', fail), list(T, nil))
           | "print" & term → T & return call(prodref('$', print), list(T, nil))
           | "any" & return call(prodref('$', any), nil)
           | terminal
           | variable → V & 
             ("←" & term → T & return set(V, T)
             | return call(prodref('$', return), list(V, nil)))
           | sq_string → T &
             $.unquote(T) → T &
             return call(prodref('$', return), list(T, nil))
           | prodref → P &
             L ← nil &
             ["(" &
              term → T & L ← list(T, L) &
              {"," & term → T & L ← list(T, L)} &
              ")"] &
             reverse(L, nil) → L &
             return call(P, L).

#            ["@" & term] &

# we only handle atoms and variables correctly for now.

term       = term0.
term0      = term1 → T & {"+" & term1 → S & T ← T + S} & T.
term1      = atom → A & L ← nil & ["(" &
                                    term → T & L ← list(T, L) &
                                      {"," & term → T & L ← list(T, L)} &
                                    ")"] &
                                    reverse(L, nil) → L &
                                    $.mkterm(A, L)
           | variable.
atom       = word
           | sq_string → T &
             $.unquote(T).

terminal   = terminal0 → T & return call(prodref('$', expect), list(T, nil)).
terminal0  = dq_string → T & $.unquote(T) → T & T
           | ("«" | "<<") & term → T & ("»" | ">>") & T.

prodref    = M ← '' & [modref → M & "."] & word → P & return prodref(M, P).
modref     = "$".
pragma     = "alias" & word & word & "=" & prodref
           | "unalias" & word.


word = $.alnum.
variable = $.upper.
sq_string = $.startswith('\'').
dq_string = $.startswith('"').


reverse(list(H, T), A) = reverse(T, list(H, A)).
reverse(nil, A) = A.
