# Desugarer for Tamsin AST, written in Tamsin.
# Distributed under a BSD-style license; see LICENSE.

tamsin_analyzer {

  desugar_all(list(H,T)) =
      desugar(H) → DH &
      desugar_all(T) → DT &
      return list(DH, DT).
  desugar_all(nil) = 'nil'.

  desugar(program(L)) = desugar_all(L) → DL & return program(DL).
  desugar(module(N, L)) =
      desugar_all(L) → DL &
      merge_prod_branches(DL, nil) → DDL &
      return module(N, DDL).
  desugar(production(N, PBs)) =
      desugar_all(PBs) → DPBs &
      return production(N, DPBs).
  desugar(prodbranch(Fs, Ls, B)) =
      desugar(B) → DB &
      return prodbranch(Fs, Ls, DB).
  desugar(call(PR, Args)) = return call(PR, Args).
  desugar(or(L, R)) = desugar(L) → DL & desugar(R) → DR & return or(DL, DR).
  desugar(and(L, R)) = desugar(L) → DL & desugar(R) → DR & return and(DL, DR).
  desugar(not(X)) = desugar(X) → DX & return not(DX).
  desugar(while(X)) = desugar(X) → DX & return while(DX).
  desugar(concat(L, R)) = desugar(L) → DL & desugar(R) → DR & return concat(DL, DR).
  desugar(using(R, P)) = desugar(R) → DR & return using(DR, P).  
  desugar(send(R, V)) = desugar(R) → DR & return send(DR, V).
  desugar(set(V, T)) = desugar(T) → DT & return set(V, DT).
  desugar(term(T)) = return term(T).
  desugar(fold(R, I)) =
      desugar(R) → DR &
      SET ← set(term('_1'), I) &
      SEND ← send(DR, term('_2')) &
      CAT ← concat(term('_1'), term('_2')) &
      ACC ← set(term('_1'), CAT) &
      RET ← call(prodref('$', 'return'), list(term('_1'), nil)) &
      return and(and(SET, while(and(SEND, ACC))), RET).

  fetch(K, list(pair(K2, V), T))  = $:equal(K, K2) & V | fetch(K, T).
  fetch(K, nil)                   = 'nil'.
  
  delete(K, list(pair(K2, V), T)) = $:equal(K, K2) & delete(K, T)
                                  | delete(K, T) → R & return list(pair(K2, V), R).
  delete(K, nil)                  = 'nil'.
  
  store(K, V, A)                  = delete(K, A) → A2 &
                                    return list(pair(K, V), A2).

  merge_prod_branches(list(production(N, list(B, nil)),T),Map) =
      fetch(N, Map) → Blist &
      Blist ← list(B, Blist) &
      store(N, Blist, Map) → Map &
      merge_prod_branches(T, Map).
  merge_prod_branches(nil,Map) =
      unmap(Map, nil).

  unmap(list(pair(K, V), T), A) =
      reverse(V, nil) → RV &
      P ← production(K, RV) &
      A ← list(P, A) &
      unmap(T, A).
  unmap(nil, A) = A.

  reverse(list(H, T), A) = reverse(T, list(H, A)).
  reverse(nil, A) = A.

  #####
  # CP = current module name (sorry)

  analyze_all(CP, list(H,T)) =
      analyze(CP, H) → DH &
      analyze_all(CP, T) → DT &
      return list(DH, DT).
  analyze_all(CP, nil) = 'nil'.

  analyze(CP, program(L)) =
      analyze_all(CP, L) → DL &
      return program(DL).
  analyze(CP, module(N, L)) =
      analyze_all(N, L) → DL &
      return module(N, DL).
  analyze(CP, production(N, Bs)) =
      analyze_all(CP, Bs) → DBs &
      return production(N, DBs).
  analyze(CP, prodbranch(Fs, Ls, E)) =
      analyze(CP, E) → DE &
      return prodbranch(Fs, Ls, DE).
  analyze(CP, call(prodref(MN, PN), As)) =
      $:equal(MN, '') & return call(prodref(CP, PN), As)
                      | return call(prodref(MN, PN), As).
  analyze(CP, or(L, R)) =
      analyze(CP, L) → DL &
      analyze(CP, R) → DR &
      return or(DL, DR).
  analyze(CP, and(L, R)) =
      analyze(CP, L) → DL &
      analyze(CP, R) → DR &
      return and(DL, DR).
  analyze(CP, not(X)) =
      analyze(CP, X) → DX &
      return not(DX).
  analyze(CP, while(X)) =
      analyze(CP, X) → DX &
      return while(DX).
  analyze(CP, concat(L, R)) =
      analyze(CP, L) → DL &
      analyze(CP, R) → DR &
      return concat(DL, DR).
  analyze(CP, using(R, P)) =
      analyze(CP, R) → DR &
      return using(DR, P).  
  analyze(CP, send(R, V)) =
      analyze(CP, R) → DR &
      return send(DR, V).
  analyze(CP, set(V, T)) =
      analyze(CP, T) → DT &
      return set(V, DT).
  analyze(CP, term(T)) =
      return term(T).

  #####
  # returns a tree of locals

  locals(call(PR, As)) =
      return nil.
  locals(or(L, R)) =
      locals(L) → LL &
      locals(R) → LR &
      return tree(LL, LR).
  locals(and(L, R)) =
      locals(L) → LL &
      locals(R) → LR &
      return tree(LL, LR).
  locals(not(X)) =
      locals(X).
  locals(while(X)) =
      locals(X).
  locals(concat(L, R)) =
      locals(L) → LL &
      locals(R) → LR &
      return tree(LL, LR).
  locals(using(R, P)) =
      locals(R).
  locals(send(R, V)) =
      locals(R).  # XXX also V!
  locals(set(V, T)) =
      locals(T).  # XXX also V!
  locals(term(T)) =
      return nil.

  # XXX need to extend the AST to cover all parts of a term.  ok...
}
