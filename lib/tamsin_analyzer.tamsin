# Desugarer for Tamsin AST, written in Tamsin.
# Distributed under a BSD-style license; see LICENSE.

tamsin_analyzer {

  desugar_all(list(H,T)) =
      desugar(H) → DH &
      desugar_all(T) → DT &
      return list(DH, DT).
  desugar_all(nil) = 'nil'.

  desugar(program(L)) = desugar_all(L) → DL & return program(DL).
  desugar(module(N, L)) =
      desugar_all(L) → DL &
      link_productions(DL, nil) → Map &
      #unmap(Map, nil) → DP &
      unmap_and_reverse_prod(Map, nil) → DP &
      return module(N, DP).
  desugar(production(N, F, Ls, E, Ps)) =
      desugar(E) → DE & return production(N, F, Ls, DE, Ps).
  desugar(call(PR, Args)) = return call(PR, Args).
  desugar(or(L, R)) = desugar(L) → DL & desugar(R) → DR & return or(DL, DR).
  desugar(and(L, R)) = desugar(L) → DL & desugar(R) → DR & return and(DL, DR).
  desugar(not(X)) = desugar(X) → DX & return not(DX).
  desugar(while(X)) = desugar(X) → DX & return while(DX).
  desugar(concat(L, R)) = desugar(L) → DL & desugar(R) → DR & return concat(DL, DR).
  desugar(using(R, P)) = desugar(R) → DR & return using(DR, P).  
  desugar(send(R, V)) = desugar(R) → DR & return send(DR, V).
  desugar(set(V, T)) = desugar(T) → DT & return set(V, DT).
  desugar(term(T)) = return term(T).
  desugar(fold(R, I)) =
      desugar(R) → DR &
      SET ← set(term('_1'), I) &
      SEND ← send(DR, term('_2')) &
      CAT ← concat(term('_1'), term('_2')) &
      ACC ← set(term('_1'), CAT) &
      RET ← call(prodref('$', 'return'), list(term('_1'), nil)) &
      return and(and(SET, while(and(SEND, ACC))), RET).

  fetch(K, list(pair(K2, V), T))  = $:equal(K, K2) & V | fetch(K, T).
  fetch(K, nil)                   = 'nil'.
  
  delete(K, list(pair(K2, V), T)) = $:equal(K, K2) & delete(K, T)
                                  | delete(K, T) → R & return list(pair(K2, V), R).
  delete(K, nil)                  = 'nil'.

  store(K, V, A)                  = delete(K, A) → A2 &
                                    return list(pair(K, V), A2).

  unmap(list(pair(K, V), T), A)   = A ← list(V, A) & unmap(T, A).
  unmap(nil, A)                   = A.

  unmap_and_reverse_prod(list(pair(K, V), T), A) =
      reverse_prod(V) → VR &
      A ← list(VR, A) &
      unmap(T, A).
  unmap_and_reverse_prod(nil, A) = A.

  insert_production(production(N, F, Ls, E, nil), Next) =
      return production(N, F, Ls, E, Next).

  link_productions(nil, Alist) = Alist.
  link_productions(list(production(N, F, Ls, E, nil), Ps), Alist) =
      Self ← production(N, F, Ls, E, nil) &
      fetch(N, Alist) → P &
      insert_production(Self, P) → Self &
      store(N, Self, Alist) → NewAlist &
      link_productions(Ps, NewAlist).

  reverse_prod(production(N, F, Ls, E, Next)) =
      reverse_prod(Next) → Next2 &
      return production(N, F, Ls, E, Next2).
  reverse_prod(nil) = 'nil'.

  #####

  analyze_all(list(H,T)) =
      analyze(H) → DH &
      analyze_all(T) → DT &
      return list(DH, DT).
  analyze_all(nil) = 'nil'.

  analyze(program(L)) = analyze_all(L) → DL & return program(DL).
  analyze(module(N, L)) = analyze_all(L) → DL & return module(N, DL).
  analyze(production(N, F, Ls, E, Ps)) = analyze(E) → DE &
      return production(N, F, Ls, DE, Ps).
  analyze(call(PR, Args)) = return call(PR, Args).
  analyze(or(L, R)) = analyze(L) → DL & analyze(R) → DR & return or(DL, DR).
  analyze(and(L, R)) = analyze(L) → DL & analyze(R) → DR & return and(DL, DR).
  analyze(not(X)) = analyze(X) → DX & return not(DX).
  analyze(while(X)) = analyze(X) → DX & return while(DX).
  analyze(concat(L, R)) = analyze(L) → DL & analyze(R) → DR & return concat(DL, DR).
  analyze(using(R, P)) = analyze(R) → DR & return using(DR, P).  
  analyze(send(R, V)) = analyze(R) → DR & return send(DR, V).
  analyze(set(V, T)) = analyze(T) → DT & return set(V, DT).
  analyze(term(T)) = return term(T).
}
