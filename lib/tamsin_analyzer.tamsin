# Desugarer for Tamsin AST, written in Tamsin.
# Distributed under a BSD-style license; see LICENSE.

tamsin_analyzer {

  desugar_all(list(H,T)) =
      desugar(H) → DH &
      desugar_all(T) → DT &
      return list(DH, DT).
  desugar_all(nil) = 'nil'.

  desugar(program(L)) = desugar_all(L) → DL & return program(DL).
  desugar(module(N, L)) =
      desugar_all(L) → DL &
      merge_prod_branches(DL, nil) → DDL &
      return module(N, DDL).
  desugar(production(N, PBs)) =
      desugar_all(PBs) → DPBs &
      return production(N, DPBs).
  desugar(prodbranch(Fs, Ls, B)) =
      desugar(B) → DB &
      return prodbranch(Fs, Ls, DB).
  desugar(call(PR, Args)) = return call(PR, Args).
  desugar(or(L, R)) = desugar(L) → DL & desugar(R) → DR & return or(DL, DR).
  desugar(and(L, R)) = desugar(L) → DL & desugar(R) → DR & return and(DL, DR).
  desugar(not(X)) = desugar(X) → DX & return not(DX).
  desugar(while(X)) = desugar(X) → DX & return while(DX).
  desugar(concat(L, R)) = desugar(L) → DL & desugar(R) → DR & return concat(DL, DR).
  desugar(using(R, P)) = desugar(R) → DR & return using(DR, P).  
  desugar(send(R, V)) = desugar(R) → DR & return send(DR, V).
  desugar(set(V, T)) = desugar(T) → DT & return set(V, DT).
  desugar(atom(T)) = return atom(T).
  desugar(constructor(T, Ts)) = return constructor(T, Ts).
  desugar(variable(N)) = return variable(N).
  desugar(fold(R, I)) =
      desugar(R) → DR &
      SET ← set(variable('_1'), I) &
      SEND ← send(DR, variable('_2')) &
      CAT ← concat(variable('_1'), variable('_2')) &
      ACC ← set(variable('_1'), CAT) &
      RET ← call(prodref('$', 'return'), list(variable('_1'), nil)) &
      return and(and(SET, while(and(SEND, ACC))), RET).

  fetch(K, list(pair(K2, V), T))  = $:equal(K, K2) & V | fetch(K, T).
  fetch(K, nil)                   = 'nil'.
  
  delete(K, list(pair(K2, V), T)) = $:equal(K, K2) & delete(K, T)
                                  | delete(K, T) → R & return list(pair(K2, V), R).
  delete(K, nil)                  = 'nil'.
  
  store(K, V, A)                  = delete(K, A) → A2 &
                                    return list(pair(K, V), A2).

  merge_prod_branches(list(production(N, list(B, nil)),T),Map) =
      fetch(N, Map) → Blist &
      Blist ← list(B, Blist) &
      store(N, Blist, Map) → Map &
      merge_prod_branches(T, Map).
  merge_prod_branches(nil,Map) =
      unmap(Map, nil).

  unmap(list(pair(K, V), T), A) =
      reverse(V, nil) → RV &
      P ← production(K, RV) &
      A ← list(P, A) &
      unmap(T, A).
  unmap(nil, A) = A.

  reverse(list(H, T), A) = reverse(T, list(H, A)).
  reverse(nil, A) = A.

  #####
  # CM = current module name

  analyze_all(CM, list(H,T)) =
      analyze(CM, H) → DH &
      analyze_all(CM, T) → DT &
      return list(DH, DT).
  analyze_all(CM, nil) = 'nil'.

  analyze(CM, program(L)) =
      analyze_all(CM, L) → DL &
      return program(DL).
  analyze(CM, module(N, L)) =
      analyze_all(N, L) → DL &
      return module(N, DL).
  analyze(CM, production(N, Bs)) =
      analyze_all(CM, Bs) → DBs &
      return production(N, DBs).
  analyze(CM, prodbranch(Fs, Ls, E)) =
      analyze(CM, E) → DE &
      locals(E) → Ls & reverse(Ls, nil) → Ls &
      return prodbranch(Fs, Ls, DE).
  analyze(CM, call(prodref(MN, PN), As)) =
      $:equal(MN, '') & return call(prodref(CM, PN), As)
                      | return call(prodref(MN, PN), As).
  analyze(CM, or(L, R)) =
      analyze(CM, L) → DL &
      analyze(CM, R) → DR &
      return or(DL, DR).
  analyze(CM, and(L, R)) =
      analyze(CM, L) → DL &
      analyze(CM, R) → DR &
      return and(DL, DR).
  analyze(CM, not(X)) =
      analyze(CM, X) → DX &
      return not(DX).
  analyze(CM, while(X)) =
      analyze(CM, X) → DX &
      return while(DX).
  analyze(CM, concat(L, R)) =
      analyze(CM, L) → DL &
      analyze(CM, R) → DR &
      return concat(DL, DR).
  analyze(CM, using(R, P)) =
      analyze(CM, R) → DR &
      return using(DR, P).  
  analyze(CM, send(R, V)) =
      analyze(CM, R) → DR &
      return send(DR, V).
  analyze(CM, set(V, T)) =
      analyze(CM, T) → DT &
      return set(V, DT).
  analyze(CM, atom(T)) = return atom(T).
  analyze(CM, constructor(T, Ts)) = return constructor(T, Ts).
  analyze(CM, variable(N)) = return variable(N).

  #####
  # returns a list of locals

  locals(call(PR, As)) =
      return nil.
  locals(or(L, R)) =
      locals(L) → LL &
      locals(R) → LR &
      union(LL, LR).
  locals(and(L, R)) =
      locals(L) → LL &
      locals(R) → LR &
      union(LL, LR).
  locals(not(X)) =
      locals(X).
  locals(while(X)) =
      locals(X).
  locals(concat(L, R)) =
      locals(L) → LL &
      locals(R) → LR &
      union(LL, LR).
  locals(using(R, P)) =
      locals(R).
  locals(send(R, V)) =
      locals(R) → LR &
      locals(V) → LV &
      union(LR, LV).
  locals(set(V, T)) =
      locals(V) → LV &
      locals(T) → LT &
      union(LV, LT).
  locals(atom(T)) =
      return nil.
  locals(constructor(T, Ts)) =
      locals_all(Ts).
  locals(variable(N)) =
      return list(N, nil).

  locals_all(nil) = nil.
  locals_all(list(H,T)) =
      locals(H) → LH &
      locals_all(T) → LT &
      union(LH, LT).

  nil = 'nil'.

  member(X, nil) = fail 'not a member'.
  member(X, list(H,T)) =
    $:equal(X, H) & H | member(X, T).

  add_elem(X, L) =
    member(X, L) & L | return list(X, L).

  union(nil, L2) = L2.
  union(list(H,T), L2) =
    add_elem(H, L2) → L2 &
    union(T, L2).

  union(Other, L2) = add_elem(Other, L2).

}
