# Compiler for a subset of Tamsin, written in Tamsin.

# Copyright (c)2014 Chris Pressey, Cat's Eye Technologies.
# Distributed under a BSD-style license; see LICENSE.

# NOTE, VERY INCOMPLETE: it could use:
#   database -- for indent/outdent (minor)
#   $:format or similar, for emitting

# REQUIRES lib/tamsin_scanner.tamsin
# REQUIRES lib/tamsin_parser.tamsin

main = tamsin_parser:parse → AST & tamsin_scanner:skippable & eof &
       tamsin_analyzer:desugar(AST) → AST &
       tamsin_analyzer:analyze(nil, AST) → AST &
       compile(AST).

prelude = $:emit('
/*
 * Generated code!  Edit at your own risk!
 * Must be linked with -ltamsin to build.
 */
#include <tamsin.h>

/* global scanner */

struct scanner * scanner;

/* global state: result of last action */

int ok;
struct term *result;
').

postlude = $:emit('
int main(int argc, char **argv) {
    FILE *input = NULL;
    char *filename = argv[1];
    char *buffer = malloc(8193);
    struct term *bufterm = NULL;

    if (filename == NULL) {
        input = stdin;
    } else {
        input = fopen(filename, "r");
    }

    assert(input != NULL);
    while (!feof(input)) {
        int num_read = fread(buffer, 1, 8192, input);
        if (bufterm == NULL) {
            bufterm = term_new(buffer, num_read);
        } else {
            bufterm = term_concat(bufterm, term_new(buffer, num_read));
        }
    }

    scanner = scanner_new(bufterm->atom, bufterm->size);
    ok = 0;
    result = term_new_from_cstring("nil");

    prod_main_main();

    if (ok) {
        term_fput(result, stdout);
        fwrite("\\n", 1, 1, stdout);
        exit(0);
    } else {
        term_fput(result, stderr);
        fwrite("\\n", 1, 1, stderr);
        exit(1);
    }
}
').

emitln(X) = $:emit(X) & $:emit('\n').
emit(X) = $:emit(X).
indent = 'ok'.
outdent = 'ok'.

compile(program(Ms)) =
    prelude &
    emit_prototypes(nil, Ms) &
    compile_all(program(Ms), nil, 'temp', Ms) &
    postlude &
    ''.

# P is the current program()
# B is the current prodbranch()
# Nm (or Mod) is the current module name
# Returns the name of where the latest result is stored, or nil.

compile_all(P,B,Mod, nil) = 'nil'.
compile_all(P,B,Mod, list(H,T)) =
    compile_r(P,B,Mod, H) & compile_all(P,B,Mod, T).

compile_r(P,B,Mod, module(N, Ps)) =
    compile_all(P,B,N, Ps).

compile_r(P,B,Mod, production(N, Bs)) =
    emit('void prod_') &
    emit(Mod) &
    emit('_') &
    emit(N) &
    emit('(') &
    make_formals_names(Bs) → FmlNms &
    emit_formals(FmlNms) &
    emitln(') {') &
    indent &
    compile_branches(P,B,Mod,FmlNms, Bs) &
    emit('result = term_new_from_cstring("No \'') &
    emit(N) &
    emitln(' matched arguments");') &
    emitln('ok = 0;') &
    outdent &
    emitln('}').

compile_branches(P,B,Mod,FmlNms, nil) = 'nil'.
compile_branches(P,B,Mod,FmlNms, list(H,T)) =
    compile_branch(P,B,Mod,FmlNms, H) & compile_branches(P,B,Mod,FmlNms, T).

compile_branch(P,B,Mod,FmlNms, prodbranch(Fs, Ls, E)) =

    # branch = ast
    # all_pattern_variables = set()

    emitln('{') &
    indent &

    # for fml_num in xrange(0, len(branch.formals)):
    #     self.emit_term(branch.formals[fml_num].to_term(),
    #                    "pattern%s" % fml_num, pattern=True)

    emitln('if (') &

    # for fml_num in xrange(0, len(branch.formals)):
    #     self.emit("    term_match(pattern%s, i%s) &&" %
    #         (fml_num, fml_num)
    #     )
    
    emitln('    1) {') &
    indent &

    # # declare and get variables which are found in patterns for this branch
    # for fml_num in xrange(0, len(branch.formals)):
    #     variables = []
    #     formal = branch.formals[fml_num]
    #     formal.to_term().collect_variables(variables)
    #     for variable in variables:
    #         self.emit('struct term *%s = '
    #                   'term_find_variable(pattern%s, "%s");' %
    #             (variable.name, fml_num, variable.name)
    #         )
    #         all_pattern_variables.add(variable.name)

    emit_locals(Ls) &
    compile_r(P, prodbranch(Fs, Ls, E), Mod, E) &

    emit('return;') &
    outdent &
    emitln('}') &
    outdent() &
    emitln('}').

compile_r(P,B,Mod, call(prodref('$', 'expect'), list(T, nil))) =
    compile_r(P,B,Mod, T) → TNm &
    emit('tamsin_expect(scanner, ') &
    emit(TNm) &
    emitln(');').

compile_r(P,B,Mod, call(prodref('$', 'return'), list(T, nil))) =
    compile_r(P,B,Mod, T) → TNm &
    emit('result = ') &
    emit(TNm) &
    emitln(';') &
    emitln('ok = 1;').

compile_r(P,B,Mod, call(prodref('$', 'fail'), list(T, nil))) =
    compile_r(P,B,Mod, T) → TNm &
    emit('result = ') &
    emit(TNm) &
    emitln(';') &
    emitln('ok = 0;').

compile_r(P,B,Mod, call(prodref('$', 'print'), list(T, nil))) =
    compile_r(P,B,Mod, T) → TNm &
    emit('result = ') &
    emit(TNm) &
    emitln(';') &
    emitln('term_fput(result, stdout);') &
    emitln('fprintf(stdout, "\\n");') &
    emitln('ok = 1;').

compile_r(P,B,Mod, call(prodref('$', 'emit'), list(T, nil))) =
    compile_r(P,B,Mod, T) → TNm &
    emit('result = ') &
    emit(TNm) &
    emitln(';') &
    emitln('term_fput(result, stdout);') &
    emitln('ok = 1;').

compile_r(P,B,Mod, call(prodref('$', 'gensym'), list(T, nil))) =
    compile_r(P,B,Mod, T) → TNm &
    emit('result = tamsin_gensym(') &
    emit(TNm) &
    emitln(');') &
    emitln('ok = 1;').

compile_r(P,B,Mod, call(prodref('$', 'repr'), list(T, nil))) =
    compile_r(P,B,Mod, T) → TNm &
    emit('result = term_repr(') &
    emit(TNm) &
    emitln(');') &
    emitln('ok = 1;').

compile_r(P,B,Mod, call(prodref('$', 'eof'), nil)) =
    emitln('tamsin_eof(scanner);').
compile_r(P,B,Mod, call(prodref('$', 'any'), nil)) =
    emitln('tamsin_any(scanner);').
compile_r(P,B,Mod, call(prodref('$', 'alnum'), nil)) =
    emitln('tamsin_alnum(scanner);').
compile_r(P,B,Mod, call(prodref('$', 'upper'), nil)) =
    emitln('tamsin_upper(scanner);').
compile_r(P,B,Mod, call(prodref('$', 'startswith'), list(T, nil))) =
    compile_r(P,B,Mod, T) → TNm &
    emit('tamsin_startswith(scanner, ') &
    emit(TNm) &
    emitln('->atom);').
compile_r(P,B,Mod, call(prodref('$', 'mkterm'), list(T, list(L, nil)))) =
    compile_r(P,B,Mod, T) → TNm &
    compile_r(P,B,Mod, L) → LNm &
    emit('result = tamsin_mkterm(') &
    emit(TNm) &
    emit(', ') &
    emit(LNm) &
    emitln(');') &
    emitln('ok = 1;').
compile_r(P,B,Mod, call(prodref('$', 'unquote'), list(T, list(L, list(R, nil))))) =
    compile_r(P,B,Mod, T) → TNm &
    compile_r(P,B,Mod, L) → LNm &
    compile_r(P,B,Mod, R) → RNm &
    emit('result = tamsin_unquote(') &
    emit(TNm) &
    emit(', ') &
    emit(LNm) &
    emit(', ') &
    emit(RNm) &
    emitln(');').

compile_r(P,B,Mod, call(prodref('$', 'equal'), list(L, list(R, nil)))) =
    compile_r(P,B,Mod, L) → LNm &
    compile_r(P,B,Mod, R) → RNm &
    emit('result = tamsin_equal(') &
    emit(LNm) &
    emit(', ') &
    emit(RNm) &
    emitln(');').

compile_r(P,B,Mod, call(prodref('$', 'reverse'), list(L, list(R, nil)))) =
    compile_r(P,B,Mod, L) → LNm &
    compile_r(P,B,Mod, R) → RNm &
    emit('result = tamsin_reverse(') &
    emit(LNm) &
    emit(', ') &
    emit(RNm) &
    emitln(');').

compile_r(P,B,Mod, call(prodref(M, N), A)) =
    emit('prod_') &
    emit(M) &
    emit('_') &
    emit(N) &
    emitln('();').

compile_r(P,B,Mod, and(L, R)) =
    compile_r(P,B,Mod, L) &
    emitln('if (ok) {') &
    indent &
    compile_r(P,B,Mod, R) &
    outdent &
    emitln('}').

compile_r(P,B,Mod, or(L, R)) =
    emitln('{') &
    indent &
    emit_decl_state(B) &
    emit_save_state(B) &
    compile_r(P,B,Mod, L) &
    emitln('if (!ok) {') &
    indent &
    emit_restore_state(B) &
    compile_r(P,B,Mod, R) &
    outdent &
    emitln('}') &
    outdent &
    emitln('}').

compile_r(P,B,Mod, not(R)) =
    emitln('{') &
    indent &
    emit_decl_state(B) &
    emit_save_state(B) &
    compile_r(P,B,Mod, R) &
    emit_restore_state(B) &
    emitln('if (ok) {') &
    indent &
    emitln('ok = 0;') &
    emitln('result = term_new_from_cstring("expected anything except");') &
    outdent &
    emitln('} else {') &
    indent &
    emitln('ok = 1;') &
    emitln('result = term_new_from_cstring("nil");') &
    outdent &
    emitln('}') &
    outdent &
    emitln('}').

compile_r(P,B,Mod, send(R, variable(VN))) =
    compile_r(P,B,Mod, R) &
    emit(VN) &
    emitln(' = result;').

compile_r(P,B,Mod, set(variable(VN), T)) =
    compile_r(P,B,Mod, T) → Nm &
    emit('result = ') &
    emit(Nm) &
    emitln(';') &
    emit(VN) &
    emitln(' = result;') &
    emitln('ok = 1;').

compile_r(P,B,Mod, while(R)) =
    emitln('{') &
    indent &
    emit_decl_state(B) &
    compile_r(P,B,Mod, atom(nil)) → SRNm &   # 'successful_result'
    emitln('ok = 1;') &
    emitln('while (ok) {') &
    indent &
    emit_save_state(B) &
    compile_r(P,B,Mod, R) &
    emitln('if (ok) {') &
    indent &
    emit(SRNm) &
    emitln(' = result;') &
    outdent &
    emitln('}') &
    outdent &
    emitln('}') &     # endwhile
    emit_restore_state(B) &
    emit('result = ') &
    emit(SRNm) &
    emitln(';') &
    emitln('ok = 1;') &
    outdent &
    emitln('}').

compile_r(P,B,Mod, concat(L, R)) =
    compile_r(P,B,Mod, L) → NmL &
    compile_r(P,B,Mod, R) → NmR &
    $:gensym('temp') → Nm &
    emit('struct term *') &
    emit(Nm) &
    emit(' = term_concat(term_flatten(') &
    emit(NmL) &
    emit('), term_flatten(') &
    emit(NmR) &
    emitln('));') &
    Nm.

compile_r(P,B,Mod, atom(T)) =
    emit('struct term *') &
    $:gensym('temp') → Nm &
    emit(Nm) &
    emit(' = term_new_from_cstring("') &
    escaped(T) → T &
    emit(T) &
    emitln('");') &
    Nm.

# TODO: this is only one way to compile a variable; there are others
compile_r(P,B,Mod, variable(VN)) =
    emit('struct term *') &
    $:gensym('temp') → Nm &
    emit(Nm) &
    emit(' = ') &
    emit(VN) &
    emitln(';') &
    Nm.

compile_r(P,B,Mod, constructor(T,Ts)) =
    emit('struct term *') &
    $:gensym('temp') → Nm &
    emit(Nm) &
    emit(' = term_new_from_cstring("') &
    escaped(T) → T &
    emit(T) &
    emitln('");') &
    list:reverse(Ts, nil) → Ts &
    emit_subterms(P,B,Nm, Nm, Ts) &
    Nm.

emit_subterms(P,B,Mod, ON, nil) = 'ok'.
emit_subterms(P,B,Mod, ON, list(H,T)) =
    compile_r(P,B,Mod, H) → Nm &
    emit('term_add_subterm(') &
    emit(ON) &
    emit(', ') &
    emit(Nm) &
    emitln(');') &
    emit_subterms(P,B,Mod, ON, T).

############### misc helpers ##############

emit_prototypes(Mod, nil) = 'ok'.
emit_prototypes(Mod, list(production(N, Bs), Tail)) =
    emit('void prod_') &
    emit(Mod) &
    emit('_') &
    emit(N) &
    emitln('();') &
    emit_prototypes(Mod, Tail).

emit_prototypes(Mod, list(module(N, Ps), Tail)) =
    emit_prototypes(N, Ps) &
    emit_prototypes(Mod, Tail).

make_formals_names(list(prodbranch(Fs, Ls, E), Tail)) = make_fmlnms(Fs, nil).

make_fmlnms(nil, Nms) = list:reverse(Nms, nil).
make_fmlnms(list(H,T), Nms) =
    $:gensym('formal') → Nm &
    Nms ← list(Nm, Nms) &
    make_fmlnms(T, Nms).

emit_formals(nil) = 'ok'.
emit_formals(list(H,nil)) =
    emit('struct term *') &
    emit(H).
emit_formals(list(H,T)) =
    emit('struct term *') &
    emit(H) &
    emit(', ') &
    emit_formals(T).

emit_locals(nil) = 'ok'.
emit_locals(list(H,T)) =
    emit('struct term *') &
    emit(H) &
    emitln(';') &
    emit_locals(T).

############### escaped #############

escaped(S) = escaped_r @ S.
escaped_r = A ← '' &
    {
        "\\" & A ← A + '\\\\'
      | "\"" & A ← A + '\\"'
      | "\n" & A ← A + '\\n'
      | any → B & A ← A + B
    } & A.

############### saving and restoring state for backtracking ##############

emit_decl_state(prodbranch(Fs, Ls, E)) =
    emit_decl_state_locals(Ls) &
    emitln('int position;') &
    emitln('int reset_position;').

emit_decl_state_locals(nil) = 'ok'.
emit_decl_state_locals(list(H,T)) =
    emit('struct term *save_') &
    emit(H) &
    emitln(';') &
    emit_decl_state_locals(T).

emit_save_state(prodbranch(Fs, Ls, E)) =
    emit_save_state_locals(Ls) &
    emitln('position = scanner->position;') &
    emitln('reset_position = scanner->reset_position;').

emit_save_state_locals(nil) = 'ok'.
emit_save_state_locals(list(H,T)) =
    emit('save_') &
    emit(H) &
    emit(' = ') &
    emit(H) &
    emitln(';') &
    emit_save_state_locals(T).

emit_restore_state(prodbranch(Fs, Ls, E)) =
    emitln('scanner->position = position;') &
    emitln('scanner->reset_position = reset_position;') &
    emit_restore_state_locals(Ls).

emit_restore_state_locals(nil) = 'ok'.
emit_restore_state_locals(list(H,T)) =
    emit(H) &
    emit(' = ') &
    emit('save_') &
    emit(H) &
    emitln(';') &
    emit_restore_state_locals(T).
