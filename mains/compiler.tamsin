# Compiler for a subset of Tamsin, written in Tamsin.

# Copyright (c)2014 Chris Pressey, Cat's Eye Technologies.
# Distributed under a BSD-style license; see LICENSE.

# NOTE, VERY INCOMPLETE: it could use:
#   database -- for indent/outdent (minor)
#   $:format or similar, for emitting

# REQUIRES lib/tamsin_scanner.tamsin
# REQUIRES lib/tamsin_parser.tamsin

main = tamsin_parser:parse → AST & tamsin_scanner:skippable & eof &
       tamsin_analyzer:desugar(AST) → AST &
       tamsin_analyzer:analyze(nil, AST) → AST &
       compile(AST).

prelude = $:emit('
/*
 * Generated code!  Edit at your own risk!
 * Must be linked with -ltamsin to build.
 */
#include <tamsin.h>

/* global scanner */

struct scanner * scanner;

/* global state: result of last action */

int ok;
struct term *result;
').

postlude = $:emit('
int main(int argc, char **argv) {
    FILE *input = NULL;
    char *filename = argv[1];
    char *buffer = malloc(8193);
    struct term *bufterm = NULL;

    if (filename == NULL) {
        input = stdin;
    } else {
        input = fopen(filename, "r");
    }

    assert(input != NULL);
    while (!feof(input)) {
        int num_read = fread(buffer, 1, 8192, input);
        if (bufterm == NULL) {
            bufterm = term_new(buffer, num_read);
        } else {
            bufterm = term_concat(bufterm, term_new(buffer, num_read));
        }
    }

    scanner = scanner_new(bufterm->atom, bufterm->size);
    ok = 0;
    result = term_new_from_cstring("nil");

    prod_main_main();

    if (ok) {
        term_fput(result, stdout);
        fwrite("\\n", 1, 1, stdout);
        exit(0);
    } else {
        term_fput(result, stderr);
        fwrite("\\n", 1, 1, stderr);
        exit(1);
    }
}
').

emitln(X) = $:emit(X) & $:emit('\n').
emit(X) = $:emit(X).
indent = 'ok'.
outdent = 'ok'.

compile(program(Ms)) =
    prelude &
    tamsin_parser:find_module('main', Ms) → MainMod &
    get_prods(MainMod) → MMPs &
    emit_prototypes(MMPs) &
    compile_all(program(Ms), nil, MMPs) &
    postlude &
    ''.

get_prods(module(N, Ps)) = Ps.

emit_prototypes(nil) = 'ok'.
emit_prototypes(list(production(N, Bs), MMPs)) =
    emit('void prod_main_') &
    emit(N) &
    emitln('();') &
    emit_prototypes(MMPs).

emit_locals(nil) = 'ok'.
emit_locals(list(H,T)) =
    emit('struct term *') &
    emit(H) &
    emitln(';') &
    emit_locals(T).

compile_all(P, B, nil) = 'ok'.
compile_all(P, B, list(H,T)) = compile_r(P, B, H) & compile_all(P, B, T).

compile_r(P, B, production(N, Bs)) =
    emit('void prod_main_') &
    emit(N) &
    emitln('() {') &
    indent &
    compile_all(P, B, Bs) &
    outdent &
    emitln('}').

compile_r(P, B, prodbranch(Fs, Ls, E)) =
    emit_locals(Ls) &
    compile_r(P, prodbranch(Fs, Ls, E), E).

compile_r(P, B, call(prodref('$', 'expect'), list(T, nil))) =
    emit_term(T, 'temp') &
    emitln('tamsin_expect(scanner, temp);').

compile_r(P, B, call(prodref('$', 'return'), list(T, nil))) =
    emit_term(T, 'temp') &
    emitln('result = temp;') &
    emitln('ok = 1;').

compile_r(P, B, call(prodref('$', 'print'), list(T, nil))) =
    emit_term(T, 'temp') &
    emitln('result = temp;') &
    emitln('term_fput(result, stdout);') &
    emitln('fprintf(stdout, "\\n");') &
    emitln('ok = 1;').

compile_r(P, B, call(prodref(M, N), A)) =
    emit('prod_main_') &
    emit(N) &
    emitln('();').

compile_r(P, B, and(L, R)) =
    compile_r(P, B, L) &
    emitln('if (ok) {') &
    indent &
    compile_r(P, B, R) &
    outdent &
    emitln('}').

compile_r(P, B, or(L, R)) =
    emitln('{') &
    indent &
    emit_decl_state(B) &
    emit_save_state(B) &
    compile_r(P, B, L) &
    emitln('if (!ok) {') &
    indent &
    emit_restore_state(B) &
    compile_r(P, B, R) &
    outdent &
    emitln('}') &
    outdent &
    emitln('}').

compile_r(P, B, send(R, variable(VN))) =
    compile_r(P, B, R) &
    emit(VN) &
    emitln(' = result;').

compile_r(P, B, set(variable(VN), T)) =
    emit_term(T, 'temp') &
    emitln('result = temp;') &
    emit(VN) &
    emitln(' = result;') &
    emitln('ok = 1;').

compile_r(P, B, while(R)) =
    emitln('{') &
    indent &
    emit_decl_state(B) &
    emit_term(atom(nil), 'successful_result') &
    emitln('ok = 1;') &
    emitln('while (ok) {') &
    indent &
    emit_save_state(B) &
    compile_r(P, B, R) &
    emitln('if (ok) {') &
    indent &
    emitln('successful_result = result;') &
    outdent &
    emitln('}') &
    outdent &
    emitln('}') &     # endwhile
    emit_restore_state(B) &
    emitln('result = successful_result;') &
    emitln('ok = 1;') &
    outdent &
    emitln('}').



emit_decl_state(prodbranch(Fs, Ls, E)) =
    emit_decl_state_locals(Ls) &
    emitln('int position;') &
    emitln('int reset_position;').

emit_decl_state_locals(nil) = 'ok'.
emit_decl_state_locals(list(H,T)) =
    emit('struct term *save_') &
    emit(H) &
    emitln(';') &
    emit_decl_state_locals(T).

emit_save_state(prodbranch(Fs, Ls, E)) =
    emit_save_state_locals(Ls) &
    emitln('position = scanner->position;') &
    emitln('reset_position = scanner->reset_position;').

emit_save_state_locals(nil) = 'ok'.
emit_save_state_locals(list(H,T)) =
    emit('save_') &
    emit(H) &
    emit(' = ') &
    emit(H) &
    emitln(';') &
    emit_save_state_locals(T).

emit_restore_state(prodbranch(Fs, Ls, E)) =
    emitln('scanner->position = position;') &
    emitln('scanner->reset_position = reset_position;') &
    emit_restore_state_locals(Ls).

emit_restore_state_locals(nil) = 'ok'.
emit_restore_state_locals(list(H,T)) =
    emit(H) &
    emit(' = ') &
    emit('save_') &
    emit(H) &
    emitln(';') &
    emit_restore_state_locals(T).



emit_term(variable(VN), N) =
    emit('struct term *') &
    emit(N) &
    emit(' = ') &
    emit(VN) &
    emitln(';').

emit_term(atom(T), N) =
    emit('struct term *') &
    emit(N) &
    emit(' = term_new_from_cstring("') &
    emit(T) &   # TODO -- escaped
    emitln('");').

emit_term(constructor(T,Ts), N) =
    emit('struct term *') &
    emit(N) &
    emit(' = term_new_from_cstring("') &
    emit(T) &   # TODO -- escaped
    emitln('");').

    #  i = 0
    #  for subterm in reversed(term.contents):
    #      subname = name + str(i)
    #      i += 1
    #      self.emit_term(subterm, subname, pattern=pattern);
    #      self.emit("term_add_subterm(%s, %s);" % (name, subname))
