# Compiler for a subset of Tamsin, written in Tamsin.

# Copyright (c)2014 Chris Pressey, Cat's Eye Technologies.
# Distributed under a BSD-style license; see LICENSE.

# NOTE, VERY INCOMPLETE: it could use:
#   database -- for indent/outdent (minor)
#   $:format or similar, for emitting

# REQUIRES lib/tamsin_scanner.tamsin
# REQUIRES lib/tamsin_parser.tamsin

main = tamsin_parser:parse → AST & tamsin_scanner:skippable & eof &
       tamsin_analyzer:desugar(AST) → AST &
       tamsin_analyzer:analyze(nil, AST) → AST &
       compile(AST).

prelude = $:emit('
/*
 * Generated code!  Edit at your own risk!
 * Must be linked with -ltamsin to build.
 */
#include <tamsin.h>

/* global scanner */

struct scanner * scanner;

/* global state: result of last action */

int ok;
struct term *result;
').

postlude = $:emit('
int main(int argc, char **argv) {
    FILE *input = NULL;
    char *filename = argv[1];
    char *buffer = malloc(8193);
    struct term *bufterm = NULL;

    if (filename == NULL) {
        input = stdin;
    } else {
        input = fopen(filename, "r");
    }

    assert(input != NULL);
    while (!feof(input)) {
        int num_read = fread(buffer, 1, 8192, input);
        if (bufterm == NULL) {
            bufterm = term_new(buffer, num_read);
        } else {
            bufterm = term_concat(bufterm, term_new(buffer, num_read));
        }
    }

    scanner = scanner_new(bufterm->atom, bufterm->size);
    ok = 0;
    result = term_new_from_cstring("nil");

    prod_main_main();

    if (ok) {
        term_fput(result, stdout);
        fwrite("\\n", 1, 1, stdout);
        exit(0);
    } else {
        term_fput(result, stderr);
        fwrite("\\n", 1, 1, stderr);
        exit(1);
    }
}
').

emitln(X) = $:emit(X) & $:emit('\n').
emit(X) = $:emit(X).
indent = 'ok'.
outdent = 'ok'.

compile(program(Ms)) =
    prelude &
    tamsin_parser:find_module('main', Ms) → MainMod &
    get_prods(MainMod) → MMPs &
    emit_prototypes(MMPs) &
    compile_all(program(Ms), nil, 'temp', MMPs) &
    postlude &
    ''.

# P is the current program()
# B is the current prodbranch()
# Nm is the current temporary name
# Returns the name of where the latest result is stored, or nil.

compile_all(P,B,Nm, nil) = 'nil'.
compile_all(P,B,Nm, list(H,T)) =
    compile_r(P,B,Nm, H) & compile_all(P,B,Nm, T).

compile_r(P,B,Nm, production(N, Bs)) =
    emit('void prod_main_') &
    emit(N) &
    emitln('() {') &
    indent &
    compile_all(P,B,Nm, Bs) &
    outdent &
    emitln('}').

compile_r(P,B,Nm, prodbranch(Fs, Ls, E)) =
    emit_locals(Ls) &
    compile_r(P, prodbranch(Fs, Ls, E), Nm, E).

compile_r(P,B,Nm, call(prodref('$', 'expect'), list(T, nil))) =
    compile_r(P,B,Nm, T) → TNm &
    emit('tamsin_expect(scanner, ') &
    emit(TNm) &
    emitln(');').

compile_r(P,B,Nm, call(prodref('$', 'return'), list(T, nil))) =
    compile_r(P,B,Nm, T) → TNm &
    emit('result = ') &
    emit(TNm) &
    emitln(';') &
    emitln('ok = 1;').

compile_r(P,B,Nm, call(prodref('$', 'print'), list(T, nil))) =
    compile_r(P,B,Nm, T) → TNm &
    emit('result = ') &
    emit(TNm) &
    emitln(';') &
    emitln('term_fput(result, stdout);') &
    emitln('fprintf(stdout, "\\n");') &
    emitln('ok = 1;').

compile_r(P,B,Nm, call(prodref(M, N), A)) =
    emit('prod_main_') &
    emit(N) &
    emitln('();').

compile_r(P,B,Nm, and(L, R)) =
    compile_r(P,B,Nm, L) &
    emitln('if (ok) {') &
    indent &
    compile_r(P,B,Nm, R) &
    outdent &
    emitln('}').

compile_r(P,B,Nm, or(L, R)) =
    emitln('{') &
    indent &
    emit_decl_state(B) &
    emit_save_state(B) &
    compile_r(P,B,Nm, L) &
    emitln('if (!ok) {') &
    indent &
    emit_restore_state(B) &
    compile_r(P,B,Nm, R) &
    outdent &
    emitln('}') &
    outdent &
    emitln('}').

compile_r(P,B,Nm, send(R, variable(VN))) =
    compile_r(P,B,Nm, R) &
    emit(VN) &
    emitln(' = result;').

compile_r(P,B,Nm, set(variable(VN), T)) =
    compile_r(P,B,Nm, T) → Nm &
    emit('result = ') &
    emit(Nm) &
    emitln(';') &
    emit(VN) &
    emitln(' = result;') &
    emitln('ok = 1;').

compile_r(P,B,Nm, while(R)) =
    emitln('{') &
    indent &
    emit_decl_state(B) &
    compile_r(P,B,'successful_result', atom(nil)) &
    emitln('ok = 1;') &
    emitln('while (ok) {') &
    indent &
    emit_save_state(B) &
    compile_r(P,B,Nm, R) &
    emitln('if (ok) {') &
    indent &
    emitln('successful_resultx = result;') &
    outdent &
    emitln('}') &
    outdent &
    emitln('}') &     # endwhile
    emit_restore_state(B) &
    emitln('result = successful_resultx;') &
    emitln('ok = 1;') &
    outdent &
    emitln('}').

compile_r(P,B,Nm, concat(L, R)) =
    compile_r(P,B,Nm, L) → NmL &
    compile_r(P,B,NmL, R) → NmR &
    Nm ← NmR + 'x' &
    emit('struct term *') &
    emit(Nm) &
    emit(' = term_concat(term_flatten(') &
    emit(NmL) &
    emit('), term_flatten(') &
    emit(NmR) &
    emitln('));') &
    Nm.

compile_r(P,B,Nm, atom(T)) =
    emit('struct term *') &
    Nm ← Nm + 'x' &
    emit(Nm) &
    emit(' = term_new_from_cstring("') &
    escaped(T) → T &
    emit(T) &
    emitln('");') &
    Nm.

# TODO: this is only one way to compile a variable; there are others
compile_r(P,B,Nm, variable(VN)) =
    emit('struct term *') &
    Nm ← Nm + 'x' &
    emit(Nm) &
    emit(' = ') &
    emit(VN) &
    emitln(';') &
    Nm.

compile_r(P,B,Nm, constructor(T,Ts)) =
    emit('struct term *') &
    Nm ← Nm + 'x' &
    emit(Nm) &
    emit(' = term_new_from_cstring("') &
    escaped(T) → T &
    emit(T) &
    emitln('");') &
    list:reverse(Ts, nil) → Ts &
    emit_subterms(P,B,Nm, Nm, Ts) &
    Nm.

emit_subterms(P,B,Nm, ON, nil) = Nm.
emit_subterms(P,B,Nm, ON, list(H,T)) =
    compile_r(P,B,Nm, H) → Nm &
    emit('term_add_subterm(') &
    emit(ON) &
    emit(', ') &
    emit(Nm) &
    emitln(');') &
    emit_subterms(P,B,Nm, ON, T).

############### misc helpers ##############

get_prods(module(N, Ps)) = Ps.

emit_prototypes(nil) = 'ok'.
emit_prototypes(list(production(N, Bs), MMPs)) =
    emit('void prod_main_') &
    emit(N) &
    emitln('();') &
    emit_prototypes(MMPs).

emit_locals(nil) = 'ok'.
emit_locals(list(H,T)) =
    emit('struct term *') &
    emit(H) &
    emitln(';') &
    emit_locals(T).

############### escaped #############

escaped(S) = escaped_r @ S.
escaped_r = A ← '' &
    {
        "\\" & A ← A + '\\\\'
      | "\"" & A ← A + '\\"'
      | "\n" & A ← A + '\\n'
      | any → B & A ← A + B
    } & A.

############### saving and restoring state for backtracking ##############

emit_decl_state(prodbranch(Fs, Ls, E)) =
    emit_decl_state_locals(Ls) &
    emitln('int position;') &
    emitln('int reset_position;').

emit_decl_state_locals(nil) = 'ok'.
emit_decl_state_locals(list(H,T)) =
    emit('struct term *save_') &
    emit(H) &
    emitln(';') &
    emit_decl_state_locals(T).

emit_save_state(prodbranch(Fs, Ls, E)) =
    emit_save_state_locals(Ls) &
    emitln('position = scanner->position;') &
    emitln('reset_position = scanner->reset_position;').

emit_save_state_locals(nil) = 'ok'.
emit_save_state_locals(list(H,T)) =
    emit('save_') &
    emit(H) &
    emit(' = ') &
    emit(H) &
    emitln(';') &
    emit_save_state_locals(T).

emit_restore_state(prodbranch(Fs, Ls, E)) =
    emitln('scanner->position = position;') &
    emitln('scanner->reset_position = reset_position;') &
    emit_restore_state_locals(Ls).

emit_restore_state_locals(nil) = 'ok'.
emit_restore_state_locals(list(H,T)) =
    emit(H) &
    emit(' = ') &
    emit('save_') &
    emit(H) &
    emitln(';') &
    emit_restore_state_locals(T).
