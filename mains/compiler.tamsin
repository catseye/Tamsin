# Compiler for a subset of Tamsin, written in Tamsin.

# Copyright (c)2014 Chris Pressey, Cat's Eye Technologies.
# Distributed under a BSD-style license; see LICENSE.

# NOTE, VERY INCOMPLETE: it could use:
#   database -- for indent/outdent (minor)
#   $:format or similar, for emitting
# ... the goal right now is just for THIS to compile.  not its output.

# REQUIRES lib/tamsin_scanner.tamsin
# REQUIRES lib/tamsin_parser.tamsin

main = tamsin_parser:parse → AST & tamsin_scanner:skippable & eof &
       compile(AST).

prelude = $:emit('
/*
 * Generated code!  Edit at your own risk!
 * Must be linked with -ltamsin to build.
 */
#include <tamsin.h>

/* global scanner */

struct scanner * scanner;

/* global state: result of last action */

int ok;
struct term *result;
').

postlude = $:emit('
int main(int argc, char **argv) {
    FILE *input = NULL;
    char *filename = argv[1];
    char *buffer = malloc(8193);
    struct term *bufterm = NULL;

    if (filename == NULL) {
        input = stdin;
    } else {
        input = fopen(filename, "r");
    }

    assert(input != NULL);
    while (!feof(input)) {
        int num_read = fread(buffer, 1, 8192, input);
        if (bufterm == NULL) {
            bufterm = term_new(buffer, num_read);
        } else {
            bufterm = term_concat(bufterm, term_new(buffer, num_read));
        }
    }

    scanner = scanner_new(bufterm->atom, bufterm->size);
    ok = 0;
    result = term_new_from_cstring("nil");

    prod_main_main0();

    if (ok) {
        term_fput(result, stdout);
        fwrite("\\n", 1, 1, stdout);
        exit(0);
    } else {
        term_fput(result, stderr);
        fwrite("\\n", 1, 1, stderr);
        exit(1);
    }
}
').

emit(X) = $:emit(X) & $:emit('\n').
indent = 'ok'.
outdent = 'ok'.

compile(program(Ms)) =
    prelude &
    tamsin_parser:find_module('main', Ms) → MainMod &
    get_prods(MainMod) → MMPs &
    compile_all(program(Ms), MMPs) &
    postlude &
    ''.

get_prods(module(N, Ps)) = Ps.

emit_prototypes(nil) = 'ok'.
emit_prototypes(list(production(N, Bs), MMPs)) =
    emit('void ') &
    emit(N) &
    emit('();') &
    emit_prototypes(MMPs).

compile_all(P, nil) = 'ok'.
compile_all(P, list(H,T)) = compile_r(P, H) & compile_all(P, T).

compile_r(P, production(N, Bs)) =
    emit('void ') &
    emit(N) &
    emit('() {') &
    indent &
    compile_all(P, Bs) &
    outdent &
    emit('}').

compile_r(P, prodbranch(Fs, Ls, E)) =
    emit('/* formals and locals... */') &
    compile_r(P, E).

compile_r(P, call(prodref(M, N), A)) =
    emit('call ' + N).

compile_r(P, and(L, R)) =
    compile_r(P, L) &
    emit('if (ok) {') &
    indent &
    compile_r(P, R) &
    outdent &
    emit('}').

compile_r(P, or(L, R)) =
    emit('{') &
    indent &
    emit_decl_state &
    emit_save_state &
    compile_r(P, L) &
    emit('if (!ok) {') &
    indent &
    emit_restore_state &
    compile_r(P, R) &
    outdent &
    emit('}') &
    outdent &
    emit('}').
compile_r(P, send(R, V)) =
    compile_r(P, R) &
    $:emit(V) &
    emit(' = result;').
compile_r(P, set(V, T)) =
    emit_term(T, 'temp') &
    emit('result = temp;') &
    $:emit(V) &
    emit(' = result;') &
    emit('ok = 1;').
compile_r(P, while(R)) =
    emit('{') &
    indent &
    emit_decl_state &
    emit_term(nil, 'successful_result') &
    emit('ok = 1;') &
    emit('while (ok) {') &
    indent &
    emit_save_state &
    compile_r(P, R) &
    emit('if (ok) {') &
    indent &
    emit('successful_result = result;') &
    outdent &
    emit('}') &
    outdent &
    emit('}') &     # endwhile
    emit_restore_state &
    emit('result = successful_result;') &
    emit('ok = 1;') &
    outdent &
    emit('}').

emit_decl_state = 'ok'.
emit_save_state = 'ok'.
emit_restore_state = 'ok'.
emit_term(T, N) = emit(N) & emit('=') & emit(T).
